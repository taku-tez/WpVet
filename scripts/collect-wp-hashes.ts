#!/usr/bin/env npx ts-node
/**
 * Collect WordPress JS Fingerprints
 * 
 * Downloads WordPress releases and calculates SHA-256 hashes
 * of known JS files for fingerprint detection.
 * 
 * Usage:
 *   npx ts-node scripts/collect-wp-hashes.ts [--versions 6.0,6.1,6.2]
 * 
 * Output:
 *   Prints TypeScript code for fingerprints-data.ts
 */

import { createHash } from 'crypto';
import { mkdir, rm, readFile } from 'fs/promises';
import { existsSync } from 'fs';
import { join } from 'path';
import { execSync } from 'child_process';

// WordPress versions to collect hashes for
const DEFAULT_VERSIONS = [
  '5.0', '5.0.1', '5.0.2', '5.0.3',
  '5.1', '5.1.1', '5.1.2', '5.1.3',
  '5.2', '5.2.1', '5.2.2', '5.2.3', '5.2.4',
  '5.3', '5.3.1', '5.3.2',
  '5.4', '5.4.1', '5.4.2',
  '5.5', '5.5.1', '5.5.2', '5.5.3',
  '5.6', '5.6.1', '5.6.2',
  '5.7', '5.7.1', '5.7.2',
  '5.8', '5.8.1', '5.8.2', '5.8.3',
  '5.9', '5.9.1', '5.9.2', '5.9.3',
  '6.0', '6.0.1', '6.0.2', '6.0.3',
  '6.1', '6.1.1', '6.1.2', '6.1.3',
  '6.2', '6.2.1', '6.2.2', '6.2.3',
  '6.3', '6.3.1', '6.3.2', '6.3.3',
  '6.4', '6.4.1', '6.4.2', '6.4.3',
  '6.5', '6.5.1', '6.5.2', '6.5.3', '6.5.4', '6.5.5',
  '6.6', '6.6.1', '6.6.2',
  '6.7', '6.7.1',
];

// JS files to collect hashes for
const JS_PATHS = [
  'wp-includes/js/jquery/jquery-migrate.min.js',
  'wp-includes/js/wp-emoji-release.min.js',
  'wp-includes/js/wp-embed.min.js',
  'wp-includes/js/jquery/jquery.min.js',
];

interface HashEntry {
  path: string;
  hash: string;
  versions: string[];
}

function normalizeContent(content: string): string {
  return content
    .replace(/^\uFEFF/, '')
    .replace(/\r\n/g, '\n')
    .replace(/\r/g, '\n')
    .trim();
}

function calculateHash(content: string): string {
  return createHash('sha256').update(content).digest('hex');
}

async function downloadAndExtract(version: string, tmpDir: string): Promise<string | null> {
  const url = `https://wordpress.org/wordpress-${version}.tar.gz`;
  const extractDir = join(tmpDir, `wordpress-${version}`);
  
  if (existsSync(extractDir)) {
    return extractDir;
  }
  
  try {
    console.error(`Downloading WordPress ${version}...`);
    execSync(`curl -sL "${url}" | tar xz -C "${tmpDir}"`, { stdio: 'inherit' });
    
    // WordPress extracts to 'wordpress' folder, rename it
    const wpDir = join(tmpDir, 'wordpress');
    if (existsSync(wpDir)) {
      execSync(`mv "${wpDir}" "${extractDir}"`);
    }
    
    return extractDir;
  } catch (error) {
    console.error(`Failed to download WordPress ${version}: ${error}`);
    return null;
  }
}

async function collectHashes(versions: string[]): Promise<Map<string, HashEntry>> {
  const tmpDir = '/tmp/wp-hashes';
  await mkdir(tmpDir, { recursive: true });
  
  // Map: hash -> { path, hash, versions }
  const hashMap = new Map<string, HashEntry>();
  
  for (const version of versions) {
    const wpDir = await downloadAndExtract(version, tmpDir);
    if (!wpDir) continue;
    
    for (const jsPath of JS_PATHS) {
      const fullPath = join(wpDir, jsPath);
      
      if (!existsSync(fullPath)) {
        console.error(`  ${jsPath} not found in ${version}`);
        continue;
      }
      
      try {
        const content = await readFile(fullPath, 'utf-8');
        const normalized = normalizeContent(content);
        const hash = calculateHash(normalized);
        
        const key = `${jsPath}:${hash}`;
        const existing = hashMap.get(key);
        
        if (existing) {
          existing.versions.push(version);
        } else {
          hashMap.set(key, {
            path: `/${jsPath}`,
            hash,
            versions: [version],
          });
        }
        
        console.error(`  ${jsPath}: ${hash.slice(0, 12)}... (${version})`);
      } catch (error) {
        console.error(`  Error reading ${jsPath}: ${error}`);
      }
    }
  }
  
  // Cleanup
  try {
    await rm(tmpDir, { recursive: true, force: true });
  } catch {
    // Ignore cleanup errors
  }
  
  return hashMap;
}

function generateTypeScript(hashMap: Map<string, HashEntry>): string {
  const entries = Array.from(hashMap.values());
  
  // Group by path
  const byPath = new Map<string, HashEntry[]>();
  for (const entry of entries) {
    const existing = byPath.get(entry.path) || [];
    existing.push(entry);
    byPath.set(entry.path, existing);
  }
  
  let output = `/**
 * WordPress JS fingerprint database
 * 
 * Auto-generated by scripts/collect-wp-hashes.ts
 * Generated: ${new Date().toISOString()}
 */

export const WP_CORE_FINGERPRINTS: JsFingerprint[] = [\n`;
  
  for (const [path, entries] of byPath) {
    output += `  // ${path}\n`;
    for (const entry of entries) {
      output += `  {\n`;
      output += `    path: '${entry.path}',\n`;
      output += `    hash: '${entry.hash}',\n`;
      output += `    versions: [${entry.versions.map(v => `'${v}'`).join(', ')}],\n`;
      output += `  },\n`;
    }
  }
  
  output += `];\n`;
  
  return output;
}

async function main() {
  const args = process.argv.slice(2);
  let versions = DEFAULT_VERSIONS;
  
  const versionsIdx = args.indexOf('--versions');
  if (versionsIdx !== -1 && args[versionsIdx + 1]) {
    versions = args[versionsIdx + 1].split(',');
  }
  
  console.error(`Collecting hashes for ${versions.length} WordPress versions...`);
  console.error('');
  
  const hashMap = await collectHashes(versions);
  
  console.error('');
  console.error(`Collected ${hashMap.size} unique hashes`);
  console.error('');
  
  // Output TypeScript
  console.log(generateTypeScript(hashMap));
}

main().catch(console.error);
